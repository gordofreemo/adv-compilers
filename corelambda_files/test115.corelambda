{-
  generated by StitchSimpleArithmetic:
  putStrLn (show term_main_ScanParseSemanticsShow_string1_55)
  (type String, value "7")
-}
let ts = app(fix(abs(scan: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))). abs(string: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). let scanInt = fix(abs(scanInt: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))). abs(ds: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). abs(string: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), string) of nil = u => app(abs(c: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), c), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TN = app(abs(ds: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). app(let f = fix(abs(f: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Int). abs(s: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), s) of nil = u => 0 | cons = p => let c = project(p.fst) in let cs = project(p.snd) in let d = -(ord(c), ord('0')) in +(d, *(10, app(f, cs))) end end end esac))) in abs(s: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). app(f, app(fix(abs(reverse: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))). abs(cs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), cs) of nil = u => fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))) | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(fix(abs(append: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))). abs(xs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). abs(ys: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), xs) of nil = u => ys | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), app(app(append, tl), ys)) end end esac)))), app(reverse, tl)), app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))) end end esac))), s))) end, app(fix(abs(reverse: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))). abs(cs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), cs) of nil = u => fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))) | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(fix(abs(append: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))). abs(xs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). abs(ys: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), xs) of nil = u => ys | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), app(app(append, tl), ys)) end end esac)))), app(reverse, tl)), app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))) end end esac))), ds))), ds) as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))) | cons = p => let c = project(p.fst) in let cs = project(p.snd) in if app(abs(c: Char. let x = ord(c) in if <(x, 58) then if <(47, x) then true else false fi else false fi end), c) then app(app(scanInt, app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), c), ds)), cs) else app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TN = app(abs(ds: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). app(let f = fix(abs(f: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Int). abs(s: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), s) of nil = u => 0 | cons = p => let c = project(p.fst) in let cs = project(p.snd) in let d = -(ord(c), ord('0')) in +(d, *(10, app(f, cs))) end end end esac))) in abs(s: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). app(f, app(fix(abs(reverse: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))). abs(cs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), cs) of nil = u => fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))) | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(fix(abs(append: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))). abs(xs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). abs(ys: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), xs) of nil = u => ys | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), app(app(append, tl), ys)) end end esac)))), app(reverse, tl)), app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))) end end esac))), s))) end, app(fix(abs(reverse: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))). abs(cs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), cs) of nil = u => fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))) | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(fix(abs(append: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))). abs(xs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). abs(ys: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), xs) of nil = u => ys | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), app(app(append, tl), ys)) end end esac)))), app(reverse, tl)), app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))) end end esac))), ds))), ds) as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, string)) fi end end esac)))) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), string) of nil = u => fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))) | cons = p => let c = project(p.fst) in let cc = ord(c) in let cs = project(p.snd) in if =(cc, ord(' ')) then app(scan, cs) else if =(cc, ord('\t')) then app(scan, cs) else if =(cc, ord('\n')) then app(scan, cs) else if =(cc, ord('x')) then app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TX = unit as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, cs)) else if =(cc, ord('+')) then app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TPlus = unit as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, cs)) else if =(cc, ord('-')) then app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TMinus = unit as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, cs)) else if =(cc, ord('*')) then app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TTimes = unit as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, cs)) else if =(cc, ord('(')) then app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TLpar = unit as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, cs)) else if =(cc, ord(')')) then app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TRPar = unit as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, cs)) else if =(cc, ord(',')) then app(app(abs(n: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit). abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))))), tag(TComma = unit as Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit))), app(scan, cs)) else if app(abs(c: Char. let x = ord(c) in if <(x, 58) then if <(47, x) then true else false fi else false fi end), c) then app(app(scanInt, app(abs(c: Char. app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), c), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), c)), cs) else fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))))))) fi fi fi fi fi fi fi fi fi fi fi end end end esac end))), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '+', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '(', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '1', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = ',', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '*', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '(', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '2', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = ',', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '-', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '(', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '7', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = ',', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = '4', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = ')', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = ')', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = ')', snd = fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) in let e = app(abs(ts: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). let resultMaybePair1 = app(fix(abs(parseExpr: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))),Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))). abs(ts: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), ts) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p => let t1 = project(p.fst) in let ts1 = project(p.snd) in case t1 of TX = u => tag(just = record(fst = fold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), tag(X = unit as Variant(X: Unit, N: Int, Plus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Minus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Times: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))))))), snd = ts1) as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(just = record(fst = fold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), tag(N = n as Variant(X: Unit, N: Int, Plus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Minus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Times: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))))))), snd = ts1) as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), ts1) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p2 => let t2 = project(p2.fst) in let ts2 = project(p2.snd) in case t2 of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => let resultMaybePair1 = app(parseExpr, ts2) in case resultMaybePair1 of nothing = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | just = resultPair1 => let e1 = project(resultPair1.fst) in let rest1 = project(resultPair1.snd) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), rest1) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p => let token = project(p.fst) in let ts2' = project(p.snd) in case token of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TRPar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => let resultMaybePair2 = app(parseExpr, ts2') in case resultMaybePair2 of nothing = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | just = resultPair2 => let e2 = project(resultPair2.fst) in let rest2 = project(resultPair2.snd) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), rest2) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p => let token = project(p.fst) in let ts2'' = project(p.snd) in case token of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TRPar = u => tag(just = record(fst = fold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), tag(Plus = record(fst = e1, snd = e2) as Variant(X: Unit, N: Int, Plus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Minus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Times: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))))))), snd = ts2'') as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) esac end end esac end end esac end esac end end esac end end esac end | TRPar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) esac end end esac | TMinus = u => case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), ts1) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p2 => let t2 = project(p2.fst) in let ts2 = project(p2.snd) in case t2 of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => let resultMaybePair1 = app(parseExpr, ts2) in case resultMaybePair1 of nothing = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | just = resultPair1 => let e1 = project(resultPair1.fst) in let rest1 = project(resultPair1.snd) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), rest1) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p => let token = project(p.fst) in let ts2' = project(p.snd) in case token of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TRPar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => let resultMaybePair2 = app(parseExpr, ts2') in case resultMaybePair2 of nothing = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | just = resultPair2 => let e2 = project(resultPair2.fst) in let rest2 = project(resultPair2.snd) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), rest2) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p => let token = project(p.fst) in let ts2'' = project(p.snd) in case token of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TRPar = u => tag(just = record(fst = fold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), tag(Minus = record(fst = e1, snd = e2) as Variant(X: Unit, N: Int, Plus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Minus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Times: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))))))), snd = ts2'') as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) esac end end esac end end esac end esac end end esac end end esac end | TRPar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) esac end end esac | TTimes = u => case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), ts1) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p2 => let t2 = project(p2.fst) in let ts2 = project(p2.snd) in case t2 of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => let resultMaybePair1 = app(parseExpr, ts2) in case resultMaybePair1 of nothing = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | just = resultPair1 => let e1 = project(resultPair1.fst) in let rest1 = project(resultPair1.snd) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), rest1) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p => let token = project(p.fst) in let ts2' = project(p.snd) in case token of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TRPar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => let resultMaybePair2 = app(parseExpr, ts2') in case resultMaybePair2 of nothing = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | just = resultPair2 => let e2 = project(resultPair2.fst) in let rest2 = project(resultPair2.snd) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), rest2) of nil = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | cons = p => let token = project(p.fst) in let ts2'' = project(p.snd) in case token of TX = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TN = n => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TPlus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TMinus = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TTimes = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TLpar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TRPar = u => tag(just = record(fst = fold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), tag(Times = record(fst = e1, snd = e2) as Variant(X: Unit, N: Int, Plus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Minus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Times: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))))))), snd = ts2'') as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) esac end end esac end end esac end esac end end esac end end esac end | TRPar = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) | TComma = u => tag(nothing = unit as Variant(nothing: Unit, just: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X)))))) esac end end esac esac end end esac))), ts) in case resultMaybePair1 of nothing = u => fold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), tag(N = 1111 as Variant(X: Unit, N: Int, Plus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Minus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Times: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))))))) | just = resultPair1 => let e = project(resultPair1.fst) in let ts' = project(resultPair1.snd) in case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Variant(TX: Unit, TN: Int, TPlus: Unit, TMinus: Unit, TTimes: Unit, TLpar: Unit, TRPar: Unit, TComma: Unit), snd: X))), ts') of nil = u => e | cons = p => fold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), tag(N = 2222 as Variant(X: Unit, N: Int, Plus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Minus: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr)))), Times: Record(fst: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), snd: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))))))) esac end end esac end), ts) in let sem = app(fix(abs(semantics: ->(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))),->(Int,Int)). abs(e: Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))). case unfold(Mu (Expr.Variant(X: Unit, N: Int, Plus: Record(fst: Expr, snd: Expr), Minus: Record(fst: Expr, snd: Expr), Times: Record(fst: Expr, snd: Expr))), e) of X = u => abs(x: Int. x) | N = n => app(abs(x: Int. abs(y: Int. x)), n) | Plus = pair => abs(x: Int. +(app(app(semantics, project(pair.fst)), x), app(app(semantics, project(pair.snd)), x))) | Minus = pair => abs(x: Int. -(app(app(semantics, project(pair.fst)), x), app(app(semantics, project(pair.snd)), x))) | Times = pair => abs(x: Int. *(app(app(semantics, project(pair.fst)), x), app(app(semantics, project(pair.snd)), x))) esac))), e) in let int = app(sem, 55) in app(let showPosIntRev = fix(abs(showPosIntRev: ->(Int,Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))). abs(n: Int. if =(n, 0) then fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))) else let d = /(n, 10) in let r = app(app(abs(n: Int. abs(m: Int. -(n, *(m, /(n, m))))), n), 10) in let cd = chr(+(r, ord('0'))) in app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), cd), app(showPosIntRev, d)) end end end fi))) in abs(n: Int. if <(n, 0) then app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), '-'), app(fix(abs(reverse: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))). abs(cs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), cs) of nil = u => fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))) | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(fix(abs(append: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))). abs(xs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). abs(ys: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), xs) of nil = u => ys | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), app(app(append, tl), ys)) end end esac)))), app(reverse, tl)), app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))) end end esac))), app(showPosIntRev, -(0, n)))) else if =(n, 0) then app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), '0'), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))))))) else app(fix(abs(reverse: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X)))). abs(cs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), cs) of nil = u => fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))) | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(fix(abs(append: ->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),->(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))),Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))). abs(xs: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). abs(ys: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). case unfold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), xs) of nil = u => ys | cons = p => let hd = project(p.fst) in let tl = project(p.snd) in app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), app(app(append, tl), ys)) end end esac)))), app(reverse, tl)), app(app(abs(n: Char. abs(l: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))). fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(cons = record(fst = n, snd = l) as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))), hd), fold(Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))), tag(nil = unit as Variant(nil: Unit, cons: Record(fst: Char, snd: Mu (X.Variant(nil: Unit, cons: Record(fst: Char, snd: X))))))))) end end esac))), app(showPosIntRev, n)) fi fi) end, int) end end end end
